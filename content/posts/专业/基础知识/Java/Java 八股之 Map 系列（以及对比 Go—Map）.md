---
title: "未命名"
date: 2025-09-04T23:54:16+08:00
lastmod: 2025-09-04T23:54:16+08:00
draft: true
tags: 
categories:
author: 小石堆
---
## Java 的 Map 种类
按照是否并发安全主要分为两大类：
1. 非并发安全 Map：HashMap
2. 并发安全 Map：HashTable、ConcurrentMap
### HashMap
HashMap 的在 Jdk1.8 后的底层实现是 **数组 + 链表 + 红黑树**。
![image.png](http://43.139.219.135:9000/blog-pic/images/20250905004833583.png)

1. 为什么会用到链表呢？主要是因为解决哈希碰撞的问题，链表就是拉链法解决
2. 为什么会用到红黑树呢？主要原因是哈希表长期以来存在的问题——劣化。当承载数据量庞大的时候，哈希表的查找时间复杂度会从 `O(1)`劣化为 `O(n)`。当链表长度过长的时候，就将链表转化为红黑树，以此来降低时间复杂度。（其实红黑树和哈希表还挺有意思的，之前和朋友聊过为什么 epoll 不用哈希表而用红黑树）
#### HashMap 的扩容和劣化
其实所有 HashMap 主要要解决的几个问题就是：
1.  扩容
2. 劣化
3. 迁移时性能抖动

**HashMap 扩容策略**：HashMap默认初始大小为 16，之后每次扩容为原来的 2 倍，然后直接迁移过去（**这里会产生严重的性能抖动，不知道为什么 Java 团队在这里没有做优化**）。
**HashMap 劣化解决策略**：当插入元素时，会先校验链表的长度是否达到 8，如果到达 8，则触发扩容，此时会先检查数组的长度是否达到 64，如果达到 64，则会将链表转化为红黑树，如果未达到 64，则会做数组的扩容，再 rehash。
1. 为什么不直接讲链表转化为红黑树？这里要注意，红黑树确实在数量级大的时候，查找效率为 `O(logn)` 优于链表，但是红黑树在维护起来时间复杂度也是`O(logn)`，当链表小于 8 时，顺序查找的时间复杂度是可以被接受的，**过早的引入红黑树收益不高**。
#### HashMap 线程安全考量
1. HashMap 线程不安全第一原因是其 `put()`，`resize()` 等方法都没有 Synchronized 等并发关键字修饰——无锁/同步机制
2. 并发写会导致数据不一致性，AB 同时写一个 key 到一个 bucket 中，可能会出现覆盖写的情况
3. JDK1.7 之前头插法扩容，并发扩容的时候可能产生死循环
### HashTable 和 ConcurrentHashMap
既然 HashMap 无并发可靠性，那么并发安全的 Map 应运而生，因为在现代操作系统项目中，多线程是主旋律，多线程访问同一个容器必须要保证这个容器是并发安全的。